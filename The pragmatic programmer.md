# The pragmatic programmer

## A Pragmatic Philosophy

- Take responsibility

  > When you make a mistake (as we all do) or an error in judgment, admit it honestly and try to offer options.
- Software Entropy
  > Don’t leave “broken windows’’ (bad designs, wrong decisions, or poor code) unrepaired. Fix each one as soon as it is discovered.
- Be a Catalyst for Change
  > Work out what you can reasonably ask for. Develop it well. Once you’ve got it, show people, and let them marvel. Then say “of course, it would be better if we added…
- Involve your users in the trade off
  > The scope and quality of the system you produce should be discussed as part of that system’s requirements.
- Your knowlendge portfolio
  > Develop a routine which you follow until your brain internalizes it. At that point, you’ll find yourself sucking up new knowledge automatically.
- Goals
  > - As a baseline, you need to know the ins and outs of the particular technology you are working with currently.
  > - Learn at least one new language every year.
  > - Read a technical book each month.
  > - Take classes
  > - Participate in local user groups and meetups
  > - Experiment with dif erent environments
  > - Stay current
- Critical thinking
  > Critically analyze what you read and hear
- Communicate
  > - Know what you want to say.
  > - Know your audience.
  > - Choose your moment.
  > - Choose a style.
  > - Make it look good.
  > - Involve your audience.
  > - Be a listener.
  > - Get back to people.
  > - Keep code and documentation together.

## A Pragmatic Approach

- ETC principle: Easier to Change

  > Good design as easier to change than bad design.
- DRY principle: Don’t Repeat Yourself
  > Every piece of knowledge must have a single, unambiguous, authoritative representation within a system.
- Orthogonality
  > Two or more things are orthogonal if changes in one do not affect any of the others
  - Keep your code decoupled
  - Avoid global data
  - Avoid similar functions
  - An orthogonally designed and implemented system is easier to test.
- Reversibility
  > Many of the topics in this book are geared to producing flexible, adaptable software. By sticking to their recommendations— especially the DRY principle, decoupling, and use of external configuration—we don’t have to make as many critical, irreversible decisions.
- Tracer Bullets
  > Tracer development is consistent with the idea that a project is never finished: there will always be changes required and functions to add. It is an incremental approach.
  - Users get to see something working early
  - Developers build a structure to work in
  - You have an integration platform
  - You have something to demonstrate
  - You have a better feel for progress
- Prototypes
  > We build software prototypes to analyze and expose risk, and to offer chances for correction at a greatly reduced cost.
- Estimating
  - Choose the units of your answer to reflect the accuracy you intend to convey
  - Understand what’s being asked
  - Build a model of the system
  - Break the model into components
  - Give each parameter a value
  - Calculate the answers
  - Keep Track of Your Estimating Prowess
  - PERT:
    - Every PERT task has an optimistic, a most likely, and a pessimistic estimate
  - What to say when asked for an estimate?

    > I’ll get back to you.
